【任務分析】
  【定義必要資料】
   1. 牌桌上的 52 張牌：用數字 0~51 表示撲克牌編號，實際使用時再除以 13 換算四種花色。
      let cards = [0, 1, 2, 3, ..., 51]
   2. 每次嘗試翻開的兩張牌：每次嘗試結束後，陣列清空。
      let revealedCards = [1, 14]
   3. 積分：配對一組得 10 分；達到 260 分則遊戲結束。
      let score = 0

  【拆解邏輯流程】
   遊戲開始
   => 發牌
   => 翻牌
      等待翻第一張
      翻第一張牌
      等待翻第二張
      翻第二張牌
   => 比對翻開兩張牌(數字是否相同)
      成功：兩張牌維持翻開 
            => 判斷是否找到所有配對(得260分)
               是：全部完成，遊戲結束
               否：回到翻牌
      失敗：兩張牌覆蓋，回到翻牌

  【確認UI規格】
   1. 牌桌：畫面夠大時，一排13張，共4排
   2. 卡片樣式
      正面：花色、數字
      背面
   3. 依照配對成功與否，卡片樣式會出現兩種變化
      成功：數字相同，底色改變，維持翻開
      失敗：數字不同，邊框閃燈，停頓幾秒後，回到覆蓋
   4. 字型：Nunito

【實作】
  【初始架構】
   1. html 元素布局
   2. css 卡片容器設定
   3. javascript MVC初始架構

  【第一張牌】
    1. 手刻 html、CSS 第一張牌
       -tml：分析 html 架構(#header 顯示標題與積分、#cards 顯示牌桌)
       -CSS：卡片在容器裡的排版、卡片內部元素的排版

    2. javascript 動態產生單張牌
       -分類 Model-View-Controller 架構

       -拆解函式
         displayCards() 負責選出 #cards 並抽換內容
         getCardElement() 負責生成卡片內部元素，包括花色、數字 

       -運算花色、數字：改寫 getCardElement()
         cards[index 0 - 12] => 黑桃 1 - 13
         cards[index 13 - 25] => 愛心 1 - 13
         cards[index 26 - 38] => 方塊 1 - 13
         cards[index 39 - 51] => 梅花 1 - 13

         宣告花色陣列 const Symbols = [ 4個花色圖片連結 ]

         數字 number = (index % 13) + 1
      　 花色 symbol = Symbols[Math.floor(index / 13)] 

       -特殊數字轉換 A、J、Q、K
         transformNumber()  將1、10、11、12、13 轉換成 A、J、Q、K

       -改寫 getCardElement()，運算數字時，呼叫transformNumber()

  【動態產生52張牌】
    1. 生成連續數字陣列：[0, 1, 2, 3, ..., 51]
       -使用 Array.from(Array(52).keys())

    2. 跌代陣列，呼叫52次 getCardElement()，產生52張牌
    3. 將產生的52個DOM元素，串成字串，當成 literal template 放進 #cards 裡
       -改寫 displayCards()
       -使用 map() 跌代陣列，依序將數字丟進 view.getCardElement()，產生有 52張牌的陣列
       -使用 join()，將陣列串成字串，當成 literal template
       -rootElement.innerHtml，將 literal template 放進 #cards 裡
      
    4. 調整 CSS 佈局：牌桌 13 * 4
       - #card 新增 flex item 換行
       - .card 新增 卡片邊距

  【現成的洗牌演算法】
    1. 從底牌開始，將它抽出，與前面任一張牌交換
    2. 接著做倒數第2張，倒數第三張... 以此類推，到頂部的第二張牌，卡片從頭到尾都被隨機排序過了
    3. 每次洗牌，都不斷跟前面任一張牌交換位置，即可保證所有牌都被換過

  【點擊時翻牌】
    1. 每張卡片加上監聽器 javascript
       -querySelectorAll('.card') 選出所有卡片 => 產出是node list(array-like 非 array)
       -forEach() 迭代每張卡片加入監聽器

    2. 加入牌背樣式 (牌桌預設顯示牌背) CSS
       -加入class="back"的樣式，使用卡片元素是否含有 .back 樣式，判斷是覆蓋狀態 or 翻開狀態

    3. 實作翻牌函式 javascript
       -get牌正面元素的函式 (有數字&花色)
         新增 getCardContent(index)
         使用者點擊時，由負責翻牌的函式 view.flipCard(card)呼叫

       -get牌背面元素的函式 (僅牌背圖)
         修改 getCardElement(index)
         遊戲初始化時，透過 view.displayCards()呼叫 (牌桌預設顯示牌背)

       -負責翻牌的函式 (判斷牌是正面、反面)
          新增 flipCard(card) 傳入card
          判斷
           原本是正面 => 顯示背面
           原本是背面 => 顯示正面

       -取得卡片索引
          卡片元素上設定 data-set，把卡片索引 (0~51) 綁在牌背上，使用者點擊卡片時，才能透過 event.target 回傳做運算
          修改getCardElement(index)：html template 綁上 data-index="${index}"
          修改flipCard(card)：傳入Number(card.dataset.index)參數 到 getCardContent() 
        
  【推進遊戲狀態，加入遊戲狀態機制】
    1. 設定遊戲狀態(設定狀態機)
       -宣告 GAME_STATE，作為狀態機，裡面定義所有的遊戲狀態

    2. 建立 MVC 架構：由 controller 依 "遊戲狀態"分配執行動作
       -宣告 controller：控制遊戲狀態推進
       定義 currentSate，代表「當前的遊戲狀態」

       -宣告 model：集中管理資料的地方
        定義 revealedCards，代表「被翻開的卡片」，是暫存牌組
        由 revealedCards 檢查依序丟入的兩張牌是否配對成功，檢查完後，即清空

       -整理程式碼：Controller 在外、view / model隱藏於內部
        程式中所有動作由 controller 統一發派，view 或 model 等其他元件只有在被 controller 呼叫時，才會動作
        調整地方如下：
          由 controller 啟動遊戲初始化，在 controller 內部呼叫 view.displayCards
          由 controller 來呼叫 utility.getRandomNumberArray，避免 view 和 utility 產生接觸

  【由 controller 統一發派動作；遊戲推進程式(執行中樞)】
    1. controller內，定義 dispatchCardAction()
      「使用者點擊卡片」後，由controller.dispatchCardAction 依照當下遊戲狀態，發派工作給 view 和 controller
         -在 FirstCardAwaits 狀態點擊卡片的話，
             卡片翻開
             revealedCards 丟入翻開的卡片
             進入 SecondCardAwaits 狀態
         -在 SecondCardAwaits 狀態點擊卡片的話
             卡片翻開
             檢查翻開的兩張卡片數字是否配對成功 ( model內新增 isRevealedCardsMatched()，用布林值檢查是否配對成功)
               配對成功 ( if isRevealedCardsMatched()為true：revealedCards內，兩張牌數字相同)
                 進入 CardsMatched 狀態
                 兩張卡維持翻開，底色改變
                 清空 revealedCards
                 進入 FirstCardAwaits 狀態             
               配對失敗 ( if isRevealedCardsMatched()為false：revealedCards內，兩張牌數字不同)
                 進入 CardsMatchFailed 狀態
                 停留 1 秒後 ( setTimeout()讓使用者記憶卡片 )
                   兩張卡翻回背面
                   清空 revealedCards
                   進入 FirstCardAwaits 狀態

  【優化與重構】
    1. 程式優化
       -改寫 flipCard()、pairedCard()函式內容：使用剩餘運算子＋map方法
       -改寫 dispatchCardAction()內，呼叫view.flipCard()、呼叫view.pairCard()傳入的參數：使用展開運算子
       -改寫 setTimeout()內執行的動作，獨立成resetCards()函式管理

    2. 畫面優化
       -畫面加入標頭：標頭區只有一個，直接修改靜態 html、CSS設定&修改樣式

    3. 計分與計算嘗試次數 (屬於資料管理)
       -model內，宣告變數 score:0、triedTimes:0
       -view內，宣告renderScore()、renderTriedTimes()
       -controller內，呼叫renderScore()、renderTriedTimes()，分配執行動作
         在狀態切換至 SecondCardAwaits，嘗試次數要 +1
         翻開兩張牌後，若配對成功，分數要 +10

    4. 配對失敗加入 CSS 動畫 (黃色邊框閃動)
       -設定 CSS 動畫樣式
          定義動畫：關鍵影格 @keyframes，指定 動畫名稱、當動畫發生時的樣式
          新增 .wrong class，在類別內 呼叫動畫、指定漸變過程(動畫持續時間、重複次數 etc.)
       -整合 javascript
          view內，宣告appendWrongAnimation()
            將傳入的 card 加上 .wrong class 
              (一旦加上，就開始跑動畫)
            加上監聽器綁定 動畫結束事件animationend
              (每次動畫結束後，把.wrong class拿掉，並設定事件執行一次之後，就卸載這個監聽器)
              (因同一張卡片可能被點錯多次，每次都要動態掛上一個新監聽器，並且用完就卸載，避免瀏覽器效能降低)
          controller.dispatchCardAction內，在配對失敗中，呼叫view.appendWrongAnimation()
              (放在setTimeout之前)

    5. 遊戲結束畫面
       -設定 CSS 遊戲結束樣式
       -view內，宣告showGameFinished()
          createElement()創建元素 + innerHTML加入元素 + node.before()插入節點
       -controller.dispatchCardAction內，新增判斷 score 是否為260分
          總分為260分
            進入 GameFinished 狀態
            呼叫view.showGameFinished()
          總分不是260分
            進入 FirstCardAwaits 狀態